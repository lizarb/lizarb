class MicroSystem::DockerShip < MicroSystem::Ship

  section :helpers

  def self.up(log_level: self.log_level)
    compose("up", log_level:)
  end

  def self.start(log_level: self.log_level)
    compose("start", log_level:)
  end

  def self.stop(log_level: self.log_level)
    compose("stop", log_level:)
  end

  def self.restart(log_level: self.log_level)
    compose("restart", log_level:)
  end

  section :default

  def self.compose(action, log_level: self.log_level)
    menv = {log_level:}

    dock(menv)

    sh "docker compose -f #{menv[:filename]} #{action}"
  end

  def self.dock(menv)
    menv[:filename] ||= "docker-compose.#{self.token}.yml"

    log_level menv[:log_level]
    comments = get_comments
    content = get_content(menv)
    content = comments + content

    puts stick system.color, content if log? :higher
    FileShell.write_text menv[:filename], content, log_level: :highest
    log "Docked #{self} to #{menv[:filename]}"
  end

  def self.get_content(menv)
    ship_menv = {log_level: menv[:log_level]}
    self.call(ship_menv)
    services = ship_menv[:services].map { [_1.to_s, _2.result] }.to_h
    content = {"services" => services}

    Object.send :require, "yaml"
    YAML.dump content
  end

  def self.call(menv)
    super

    ship = menv[:ship] ||= new
    menv[:services] = {}
    used_services.each do |name, used_service|
      menv[:services][name] = used_service
      used_service.process(ship)
    end
  end

  def self.get_comments
    content = FileShell.read_text self.source_location_path, log_level: :higher
    Object.send :require, "digest/md5"
    md5 = Digest::MD5.hexdigest content
    path = self.source_location_path.sub App.root.to_s, ""
    <<~YAML
      # DO NOT EDIT THIS FILE MANUALLY - THIS FILE WAS AUTO-GENERATED
      #
      # This docker-compose.yml was generated from service definitions in:
      #   #{path} (#{self})
      #
      # MD5: #{md5}
      #
      # To regenerate this file, run:
      #   liza ship:compose
      #
      # To run the services defined here:
      #   docker compose up
      #
      # To run and stop services using detached mode:
      #   docker compose up -d
      #   docker compose down
    YAML
  end

  section :services

  def self.defined_services
    fetch(:defined_services) { {} }
  end

  def self.used_services
    @used_services ||= {}
  end

  class Service
    def initialize(name, supername)
      @name = name
      @supername = supername
    end

    def blocks()= @blocks ||= []
    def result()= @result ||= {}

    def add_block(block)
      blocks << block if block
    end

    attr_accessor :name, :supername, :ship, :ship_class

    def process(ship)
      @ship = ship
      raise ArgumentError, "ship must be an instance" unless ship.is_a? MicroSystem::Ship
      process_ship_class
      process_blocks_shifting
      process_blocks
      process_persisted_volume
      process_default_port
    end

    def process_ship_class
      self.ship_class = Liza.const(:"#{ship_class}_ship") if ship_class.is_a?(Symbol)
    end

    def process_blocks_shifting
      service = ship_class.defined_services[supername]
      raise "service #{name} not defined in #{ship_class}" if service.nil?
      @blocks = service.blocks + blocks
    end

    def process_blocks
      blocks.each do |block|
        self.instance_eval(&block)
      end
    end

    def process_persisted_volume
      volumes "./data/#{App.mode}/micro_ships/#{name}:#{persisted}" if persisted
    end

    def process_default_port
      port default_port unless result.key?("ports")
    end

    # properties

    def image(string)
      result["image"] = string
    end

    def command(string)
      result["command"] = string
    end

    def working_dir(string)
      result["working_dir"] = string
    end

    def default_port(number=nil)
      if number
        @default_port = number
      else
        @default_port
      end
    end

    def port(host_port, container_port=default_port)
      raise "not default port" unless default_port
      ports "#{host_port}:#{container_port}"
    end

    def ports(string)
      raise "not default port" unless default_port
      raise "must include ':'" unless string.include? ":"

      result["ports"] ||= []
      result["ports"] << string unless result["ports"].include? string
    end

    def persisted(path = nil, mode: nil)
      if path
        @persisted = path
        @persisted += ":#{mode}" if mode
      else
        @persisted
      end
    end

    def readonly(path)
      volumes "#{path}:#{path}:ro"
    end

    def volume(key, container_path, mode: nil)
      host_path = ship.volume_for(name, key).to_s
      host_path += ":#{mode}" if mode

      volumes "#{host_path}:#{container_path}"
    end

    def volumes(string)
      raise "must include ':'" unless string.include? ":"
      result["volumes"] ||= []
      result["volumes"] << string unless result["volumes"].include? string
    end

    def environment(hash)
      hash = hash.map {|k, v| [k.to_s, v.to_s] }.to_h
      result["environment"] ||= {}
      result["environment"].merge! hash
    end

    # TODO: support condition
    # depends_on:
    #   rocketchat_mongodb:
    #     condition: service_healthy
    def depends_on(*services)
      raise "At least one dependency required" if services.empty?
      unless services.all? { |s| s.is_a?(Symbol) || s.is_a?(String) }
        raise "Dependencies must be symbols or strings"
      end
      result["depends_on"] = services.map(&:to_s)
    end

    def restart(value)
      allowed = 
      {
        no:             "no",
        always:         "always",
        on_failure:     "on-failure",
        unless_stopped: "unless-stopped"
      }

      key = value.to_sym
      raise "#{value.inspect} not in #{allowed.keys.inspect}" unless allowed.key?(key)

      result["restart"] = allowed[key]
    end

    def set_value(key, value)
      result[key.to_s] = value
    end

    def add_value(key, value)
      result[key.to_s] ||= []
      result[key.to_s] << value
    end

  end

  def self.define_service(name, &block)
    log :highest, "defining #{name.inspect}"
    defined_services[name] ||= Service.new(name, name)
    defined_services[name].add_block block
  end

  def self.use_service(supername, name=supername, ship: self, &block)
    defined_service = defined_services[supername]

    used_service = used_services[name] ||= Service.new(name, supername)
    used_service.ship_class = ship
    used_service.add_block block

    log :highest, "using #{name.inspect}"
  end

  define_service :empty

  section :helpers

  def volume_for(name, key)
    cl.data_directory.join("volume_#{name}_#{key}")
  end

end
